# STRUCT

# Structures

Collection of items which may be of different types

Same as classes in Java

Structs

- Use named, not structural, type equivalence
- Untagged structs are each a different type

## Structs declaration

```c
struct [ <optional tag> ] [ {
	<type declaration>;
	<type declaration>;
	...
} ] [ <optional variable list> ];
```

- Struct declarations that have a member list in curly braces define a
new type, specifically a struct type.
- If the optional tag is omitted it creates an unnamed struct type
that’s different from every other struct type.
- Filling in <optional variable list> often makes the declaration also a definition; the variables defined appear in the function’s name scope just like any other variable.
- Struct tags are in a separately-scoped name space from variables, i.e. a struct variable can have the same name as a struct tag without causing confusion
- Struct member names are in yet another name space local to the structure type, e.g. every structure type could have a member named “next”

## Struct Initialization

```c
struct mystruct_tag {
	int myint;
	char mychar;
	char mystr[20];
};
struct mystruct_tag ms = {42, 'f', "goofy"};
```

## Copying Structs

```c
struct s {
	int i;
	char c;
} s1, s2;
s1.i = 42;
s1.c = 'a';
s2 = s1; //for loop copy of s1 to s2. Cloning
s1.c = 'b';
s2.i //42
s2.c //a
//Note that assigning the structure just copied the 
//bytes from one memory block to another. There is 
//no connection between them.
```

```c
struct s {
	int i;
	char c[8];
} s1, s2;
s1.i = 42;
strcpy(s1.c, "foobar"); 
s2 = s1; 
//Since we assigned s1 to s2, s2.c is going to contain 
//exactly the same characters as are in s1.c, even 
//including the unspecified character at s1.c[7]!
s2.i //42
s2.c //'f','o','o','b','a','r','\0'
```

## Memory Storage

```c
struct {
	char mychar; 
	int myint;
	char mystr[19];
} mystruct;
```

- Example
    
    ![Screen Shot 2021-12-01 at 02.36.58.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.36.58.png)
    
    ![Screen Shot 2021-12-01 at 02.37.11.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.37.11.png)
    
    ![Screen Shot 2021-12-01 at 02.37.30.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.37.30.png)
    
    Structs are usually filled out to meet the most stringent alignment of its members
    
    sizeof(mystruct) =28
    
    ![Screen Shot 2021-12-01 at 02.41.42.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.41.42.png)
    

```c
#include <stdio.h>
struct {
	char mychar; 
	int myint;
	char mystr[19];
} mystruct;
int main() {
	printf("Address of mystruct = %p\n", (void *)&mystruct);
	printf("Offset of mychar = %ld\n",
	(void *)&mystruct.mychar - (void *)&mystruct);
	printf("Offset of myint = %ld\n",
	(void *)&mystruct.myint - (void *)&mystruct);
	printf("Offset of mystr = %ld\n",
	(void *)mystruct.mystr - (void *)&mystruct);
	printf("Size of mystruct = %ld\n", sizeof(mystruct));
}
/*
$ gcc sizes.c
$ ./a.out
Address of mystruct = 0x10ae74018
Offset of mychar = 0
Offset of myint = 4
Offset of mystr = 8
Size of mystruct = 28
*/
```

## Indexing into a String

![Screen Shot 2021-12-01 at 02.46.14.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.46.14.png)

![Screen Shot 2021-12-01 at 02.46.24.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.46.24.png)

## Arrays of Structs

![Screen Shot 2021-12-01 at 02.47.00.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.47.00.png)

![Screen Shot 2021-12-01 at 02.47.09.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.47.09.png)

## Summary

Struct may

- be copied or assgined
- have their address taken with &
- have their members accessed
- be passed as arguments to functions
- be returned from functions

Struct may not

- be compared

- In-class quiz question 1
    
    ![Screen Shot 2021-12-01 at 02.25.49.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.25.49.png)
    
    - Answer
        
        D.   mystr is a constant pointer to an array, and mystr = "any string" is incorrect. strcpy is allowed
        
- In-class quiz question 2
    
    ![Screen Shot 2021-12-01 at 02.30.33.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.30.33.png)
    
    - Answerr
        
        A
        
- In-class quiz question 3
    
    ![Screen Shot 2021-12-01 at 02.44.36.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.44.36.png)
    
    - Answrer
        
        Yes
        
- In-class quiz question 4
    - Answer
        
        ![Screen Shot 2021-12-01 at 02.50.17.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.50.17.png)
        
        - Answer
            
            ![Screen Shot 2021-12-01 at 02.50.42.png](STRUCT%2082d21c394ab54e678b94a48dd66e9fe6/Screen_Shot_2021-12-01_at_02.50.42.png)