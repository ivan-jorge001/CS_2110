# Bonus Questions

Type: Quiz 3 Material

Example: what are the values in registers R0-R4 after the following code executes?

[https://lh3.googleusercontent.com/SbHMLGlU_7u-zMCa4hvzoGVkk7XDTEQszsDySVcOFUsZUBCJUHjvd09pg-TUGwnTdb6CgXu0iujT8g7kONUMZCf2Htjq_2u9WaR7BDfPeLo3QqLkoUGcjEJii9FeYFwiC3Uv8jTC=s1600](https://lh3.googleusercontent.com/SbHMLGlU_7u-zMCa4hvzoGVkk7XDTEQszsDySVcOFUsZUBCJUHjvd09pg-TUGwnTdb6CgXu0iujT8g7kONUMZCf2Htjq_2u9WaR7BDfPeLo3QqLkoUGcjEJii9FeYFwiC3Uv8jTC=s1600)

- **R0: PC + PCOffset9 = x3001 + x0005 = x3006**
- **R1: Mem[PC + PCOffset9] = Mem[x3006] = x4002**
- **R2: Mem[Mem[PC + PCOffset9]] = Mem[Mem[x3006] = Mem[x4002] = x0003**
- **R3: Mem[BaseR + Offset6] = Mem[x3006 + x1] = Mem[x3007] = x4001**
- **R4: Mem[BaseR + Offset6] = Mem[x4002 - x1] = x0002**

PC + PCOffset = Label Address

**Explanation**

Going line by line:

[Untitled](Bonus%20Questions%20df2893473b5949cbb5abc02938397455/Untitled%20Database%208fc5d76da08e4c8bb0f7904b30291b41.csv)

**Laying out Address spaces:**

- .orig x3000 establishes the block of code to be put in @ x3000. This instruction does not use up memory x3000
    
    LEA, R0, A @ x3000
    
    LD R1, A @ x3001
    
    LDI R2, A @x3002
    
    LDR R3, R0, 1 @x3003
    
    LDR R4, R1, -2 @x3004
    
    HALT @x3005 (pls correct if this is wrong lol)
    

And the initialization of labels will take up subsequent memory spaces as well so:

A .fill x4002 @ NOT x4002 but x3006

B .fill x4001 @ NOT x4001 but x3007

This block of code is marked by .end (which again does not take memory space)

.orig x4000 starts new block of code at x4000

.fill 1 @x4000

.fill 2 @x4001

.fill 3 @x4002

.end

**Back to the actual assembly instructions:**

- **R0:**
- LEA takes the literal address at label A and puts it into R0. Which would be **x3006.**
- What's written in the study guide is the bare-bones definition of the instruction LEA as the label A is interpreted into the PC offset.
- This is done by taking the address of A and subtracting the PC from it.
- This would be x3006 - x3001 (since at line x3000 the PC contains the next instruction which is x3001) = x0005.
- **R1:**
    - This instruction takes place at LD R1, A @ x3001
    - Remember, LD takes the address at label A, accesses the memory/value associated with it, and stores it into R1.
        - Do not mistake this for LEA or LDI.
    - Label A is translated into its PC + PCOffset9:
        - Label A is at x3006
        - PC is x3002 (since we are at address x3001)
        - X3006 - x3002 = x0004
    - **Mem[PC + PCOffset9] = Mem[x3002 + x0004] = Mem[x3006] = x4002**
    - Mem[x3006] is the value AT x3006 so x4002.
- **R2:**
    - Takes place at x3002 LDI R2, A
    - Note: LDI takes VALUE @ label -> reads it as a memory address -> accesses value AT that new “memory address” -> puts value into register
    - So, to translate the instruction.
    - Label A holds value x4002.
        - Read said value as address
        - Access value at this address so Mem[x4002] = x0003
        - Put into register R2: R2 = x0003
    - To translate into the literal answer:
        - PC = x3003 (x3002 + 1)
        - Label A @ x3006
        - X3006 - x3003 = x0003
    - **Mem[fileMem[PC + PCOffset9]] = Mem[Mem[x3003 + x0003]] = Mem[x3006] = x0003**
- **R3:**
    - LDR, R3, R0, 1
    - Address: x3003
    - PC: x3004
    - LDR:
        - Taking the value inside the source register (R0) = x3006
        - Reads value as an address
        - Adds the base offset to said address: x3006 + 1 = x3007
        - Accesses the value at that new address: Mem[x3007] = x4001
        - Puts it into R3
    - **Mem[BaseR + Offset6] = Mem[x3006 + x1] = Mem[x3007] = x4001**
- **R4:**
    - LDR R4, R1, -1
    - Address: x3004
    - PC: x3005
    - Same as R3 example
        - Value inside SR (R1) = x4002
        - Read said value as address
        - Adds base offset to said address: x4002 -1 = x4001
        - Accesses value at new address: Mem[x4001] = 1
        - Puts it into R4
    - **Mem[BaseR + Offset6] = Mem[x4002 - x1] = Mem[x4001] = 2**

---